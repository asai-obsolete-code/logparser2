#!/bin/sh
#|-*- mode:lisp -*-|#
#| <Put a one-line description here>
exec ros -Q -- $0 "$@"
|#

(load "common.lisp")
(load "plot-common.lisp")
(in-package :ros.script.plot)
(cl-syntax:use-syntax :cl-interpol)

(defun futures ()
  (iter outer
        (for measure in '(:evaluation :expansion :generation))
        (iter (for config in
                   (retrieve-by-sql
                    (select (:algorithm_id :heuristics_id)
                      (from :fig2)
                      (group-by :algorithm_id :heuristics_id))))
              (task measure config))))

(defun task (measure config &aux improved? sum-improved? (base base) (macro (%id "macro" :tag)))
  (match config
    ((list _ alg _ h)
     (with-plots (s)
       (setup #?"${(db-symbol-name alg :algorithm)} ${(db-symbol-name h :heuristics)} ${measure}"
              #?"${measure}/all-domain-${(db-symbol-name alg :algorithm)}-${(db-symbol-name h :heuristics)}"
              t 1)
       (plot "x" :title "y=x")
       (when-let ((data (retrieve-by-sql
                         (select (list (make-keyword (symbolicate :base. measure))
                                       (make-keyword (symbolicate :macro. measure))
                                       :domain.id
                                       :domain.name)
                           (from (:as :fig2 :base) (:as :fig2 :macro) :domain)
                           (where
                            (:and (:= :base.problem :macro.problem)
                                  (:= :base.domain_id :macro.domain_id)
                                  (:= :base.domain_id :domain.id)
                                  (:= :base.heuristics_id h)
                                  (:= :macro.heuristics_id h)
                                  (:= :base.algorithm_id alg)
                                  (:= :macro.algorithm_id alg)
                                  (:= :base.tag_id base)
                                  (:= :macro.tag_id macro)))
                           (order-by :domain.id)))))
         (iter outer
               (while data)
               (match data
                 ((list* (list (@@ 4 _)
                               _ d _ dname) _)
                  (plot (lambda ()
                          (iter (for datum in data)
                                (match datum
                                  ((list* _ x _ y _ (= d) _)
                                   (format s "~&~a ~a" (correct x) (correct y))
                                   (pop data))
                                  (_
                                   (in outer (next-iteration))))))
                        :title dname)))))))))


